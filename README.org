#+AUTHOR: wfj
#+EMAIL: wufangjie1223@126.com
#+OPTIONS: ^:{} \n:t email:t
#+HTML_HEAD_EXTRA: <style type="text/css"> body {padding-left: 26%; background: #e3edcd;} #table-of-contents {position: fixed; width: 25%; height: 100%; top: 0; left: 0; overflow-y: scroll; resize: horizontal;} i {color: #666666;} pre, pre.src:before {color: #ffffff; background: #131926;} </style>
#+HTML_HEAD_EXTRA: <script type="text/javascript"> function adjust_html(){document.getElementsByTagName("body")[0].style.cssText="padding-left: "+(parseInt(document.getElementById("table-of-contents").style.width)+5)+"px; background: #e3edcd;"}; window.onload=function(){document.getElementById("table-of-contents").addEventListener("mouseup",adjust_html,true)}</script>

* 密码学基础
** [定义] 什么是域 F(ield) ?
满足以下八条:
1. 对于加法和乘法运算封闭 (即域内任意两个元素相加或相乘仍在域内)
2. 加法和乘法均满足结合律
3. 加法和乘法均满足交换律
4. 满足分配律
5. 存在零元 0, 使得任意 a + 0 = a
6. 存在幺元 1, 使得任意 a * 1 = a
7. 存在加法逆元 (本文简称负元)
8. 非零元存在乘法逆元 (本文简称逆元)

** [数学描述]
1. \forall a, b \in F, a + b \in F, a * b \in F
2. \forall a, b, c \in F, (a + b) + c = a + (b + c), (a * b) * c = a * (b * c)
3. \forall a, b \in F, a + b = b + a, a * b = b * a
4. \forall a, b, c \in F, a * (b + c) = a * b + a * c
5. \exists 0, s.t. \forall a \in F, a + 0 = a
6. \exists 1 \ne 0, s.t. \forall a \in F, a * 1 = a
7. \forall a, \exists -a \in F, s.t. a + (-a) = 0
8. \forall a \ne 0, \exists a^{-1} \in F, s.t. a * a^{-1} = 1

** [性质]
由以上的定义, 我们可以在域内:
+ 定义减法: 加上一个负元
+ 定义除法: 乘以一个逆元 (要求非零元)
+ 定义数乘: 连续相加
+ 定义乘方: 连续相乘
+ 等式两边同时进行四则运算

** 常见的域
+ 有理数域
+ 实数域
+ 整数模 p, 记为 F_{p} (若无特殊说明, 本文的 p 均表素数)

注: 整数不是域, 因为除法不封闭

** 群和环
+ 群 (Group): 集合 + 加法 (只实现了加法的 "域", 称为阿贝尔群, 条件再放宽一点还有其他各种群, 略)
+ 环 (Ring): 集合 + 加法 + 乘法 (这个乘法的要求没域那么高, 比如整数环)

** [证明] 整数模 p 是一个域
+ 定义加法: 普通加法然后模 p
+ 定义乘法: 普通乘法然后模 p

显然满足定义的 1~6 条, 易知第 7 条也满足, 证明第 8 条如下:

对于域内的任意非零元 x, 分别乘以 0 到 p - 1, 然后模 p, 用反证法:

假设域内有两个不同的数 a, b, 使得 x * a \equiv x * b (mod p),

那么就有 x * (a - b) \equiv 0 (mod p),

又因为 p 是素数, 因子只能是 1 和 p, x 在域内不能是 p, a - b 在域内也不能是 p,

矛盾, 所以有这 x * 0~p 的余数各不相同, 所以必存在逆元 x^{-1} 使得余数为 1

例: F_{5}: 1^{-1} = 1, 2^{-1} = 3, 3^{-1} = 2, 4^{-1} = 4

特别地, 根据定义 6, 1 的逆元始终是 1

** 辗转相除法 (也称为扩展欧几里得算法)
求逆元如果每次都需要乘 1~p-1 遍历的话, 那么 p 很大的时候就相当低效了

求两个整数的最大公约数, 通过同余, 可以得到一种快速计算方法: 辗转相除法

非零元 a 和 p 互素, 所以最大公约数为 1, 也就是可以通过辗转相除最终得到 1, 这个 1 就是我们求逆元时想得到的 1,

因此, 我们可以反推辗转相除法的过程, 最终的余数 1 可以用 a 和 p 线性表出, a 前的系数就是我们要找的逆元

注: 确切地说, 这个系数可以是任意整数 (不一定在 F_{p} 内), 但能通过模 p, 转到 F_{p} 内, 且不会改变同余关系;

另一种做法是上述的计算都用 F_{p} 内定义的计算来进行, 由封闭性可得系数也在 F_{p} 内

*** 最大公约数
#+begin_src python
  def gcd(a, b): # a >= 0, b >= 0
      def _gcd(a, b):
	  return a if b == 0 else _gcd(b, a % b)
      return _gcd(a, b) if a > b else _gcd(b, a)
#+end_src

*** 求逆元
尾递归版本, 注: 本实现返回的数可能不在域内 (负数), 需要再 mod p
#+begin_src python
  def inv(a, b): # a >= 0, b >= 0
    def gcd(a, b, k1, k2):
        if b == 1:
            return k2
        k = a // b
        return gcd(b, a - k * b, k2, k1 - k * k2)
    return gcd(a, b, 0, 1) if a > b else gcd(b, a, 0, 1)
#+end_src

*** 实现原理
其实很朴素, 辗转相除有以下等式:
#+begin_src
+ a = k1 * p + p2                  (1)
+ p = k2 * p2 + p3                 (2)
+ ...
+ pn_2 = kn_1 * pn_1 + pn          (n-1)
+ pn_1 = kn * pn + 1               (n)
#+end_src

分析如下:
+ 由式 (1), 我们可以看出: 最终的展开式, 如果有一个 p2 那么就有一个 a, 而有多少个 p 对 a 无影响
+ 现假设有一个函数 f, 能够求出上述的对应关系, 那么我们就有 f(2) = 1, f(1) = 0 (即起始条件)
+ 由式 (n-1), 我们可以得出: f(n) = f(n - 2) - kn_1 * f(n - 1) 的递推关系
+ 由式 (n), 我们可以得出结束条件

** 欧拉定理
*** 欧拉函数 \phi(n)
定义: 小于等于 n, 且与 n 互素 (即最大公约数为 1) 的正整数的个数

注: 等于仅在 n = 1 时起作用, 因为 gcd(n, n) = n

例: \phi(1) = 1, \phi(2) = 1, \phi(3) = 2, \phi(4) = 2, \phi(5) = 4

特别地, n 为素数时, \phi(n) = n - 1, 因为 1~n-1 都与 n 互素

*** 欧拉定理
若正整数 n, a 互素, 即 gcd(n, a) = 1, 则 a^{\phi(n)} \equiv 1 (mod n)

*** 证明
n = 1 时显然成立, 不妨设 n > 1,

记与 n 互素且小于 n 的数为: x_{i}, i = 1..\phi(n),

令 y_{i} = a * x_{i} (mod n), 显然有 y_{i} 与 n 互素,

\forall i \ne j, y_{i} - y_{j} = a * (x_{i} - x_{j}) (mod n) \ne 0

即任意 y_{i} 不同余, 也就是说 y_{i} 是 x_{i} 的一个重排列,

那么, \prod x_{i} \equiv \prod y_{i} \equiv \prod a * x_{i} \equiv a^{\phi(n)} * \prod x_{i} (mod n)

a^{\phi(n)} \equiv 1 (mod n), 证毕

*** 推论: 费马小定理
任意素数 p 和正整数 a, 若 a 不是 p 的倍数, 则 a^{p - 1} \equiv 1 (mod p)

证明: p 为素数, 所以 \phi(p) = p - 1, 又 a 不是 p 的倍数, 所以 a, p 互素, 满足欧拉定理条件, 带入即得 a^{p - 1} \equiv 1 (mod p)

*** 欧拉函数的性质
如果 n 的标准因式分解为 p1^{x1} * ... * pn^{xn}, 那么 \phi(n) = n * (1 - 1/p1) * ... * (1 - 1/pn)

证明: 为了简单起见只给出描述性证明

与 n 互素的情况, 可以用容斥原理表述:
1. 首先假设 n 个元素都互素
1. 然后排除被 pi 整除的情况 (共有 \sum n / pi^{xi} 种)
2. 再加上能被 pi * pj 整除的情况
3. ...

所有这些加起来正好等于 \phi(n) = n * (1 - 1/p1) * ... * (1 - 1/pn) 展开

特别地, n 为素数时, \phi(n) = n - 1, n = p * q 时, \phi(n) = (p - 1) * (q - 1)

** 本原元 (原根)
*** 阶
n 为大于 1 的整数, a, n 互素, 使得 a^{n} \equiv 1 (mod n) 成立的最小整数 x 称为 a 模 n 的阶, 符号为 Ord_{n}(a)

存在性: 由欧拉定理, 可知存在 x = \phi(n) \equiv 1 (mod n),

例:
+ Ord_{7}(1) = 1, # 1
+ Ord_{7}(2) = 3, # 2, 4, 1
+ Ord_{7}(3) = 6, # 3, 2, 6, 4, 5, 1
+ Ord_{7}(4) = 3, # 4, 2, 1
+ Ord_{7}(5) = 6, # 5, 4, 6, 2, 3, 1
+ Ord_{7}(6) = 2, # 6, 1

注: 可以看出, 因为有 \phi(n) 保底, 所以 Ord_{n}(x) 都是 \phi(n) 的因子

*** 本原元 (原根) (primitive roots)
满足 Ord_{n}(x) = \phi(n) 的 x

+也就是 F_{p} 拥有最大阶的元素, 可以有多个, 比如 Ord_{7} 的 3 和 5-+

TODO: 存在性

扩展: 生成元, 有类似的定义, 有兴趣可以了解一下

** ElGamal
1. 生成私钥 x
2. 通过 y \equiv g^{x} (mod p), 生成和计算公钥 (y, g, p)
3. 加密: 发送消息 M 时, 随机生成一个临时私钥 k, 发送 C1 = g^{k} (mod p) 和 C2 = y^{k} * M (mod p)
4. 解密: 那么拥有私钥的一方就可以通过 C2 / (C1^{x}) = y^{k} * M / g^{k*x} = M 来解密

+ 注1: 消息的二进制表示就是那个要来计算的整数 M, 要求 < p
+ 注2: 解密时用的不是实数域的除法, 而是 F_{p} 上的除法, 需要用逆元的定义, 以及交换律和结合律
+ 注3: 安全依据: 离散对数难题 (知道了上述公钥, 不能通过类似求对数的方法快速求出私钥 x)
+ 注4: g 的选择, 根据上一节, 若 g 是本原元, 能最大程度提高安全性

** 数字签名
+ 签名: signature(hash(M), private_key) -> sig
+ 验证: validate(hash(M), public_key, sig) -> bool

TODO: 为什么不直接用 M, 而是需要 hash(M), 效率? 安全?

+ 注1: 保证在验证时公钥是不可以被篡改, 或者说有能力鉴别公钥的真伪, 这时就需要 CA 和数字证书了
+ 注2: 防止重放攻击 (比如多次付款), 这时就需要在消息内写上消息编号之类的数据

** [作用] 为什么是密码学的基础
F_{p} 上的四则运算会在密码学频繁用到, 我们知道了 F_{p} 是一个域, 那么我们就可以放心地做各种复杂的运算了

* ECC (椭圆曲线密码学)
** 参考资料
https://zhuanlan.zhihu.com/p/42629724

这篇文章, 背景介绍可以看看, 举的几个例子用来入门很不错

** 椭圆曲线的一般形式
椭圆曲线方程: y^{2} = x^{3} + a * x + b, 其中 a, b 为指定常数 (貌似还有一些特殊限制, 我的知识储备不足以了解这些细节, 不过现在也用不上)

+ 注1: 这个是定义在实数域上的, 一定要注意与下面要讲的密码学中定义在有限域上的椭圆曲线的区别
+ 注2: 这个一般形式, 我们只会在后面证明加法的封闭性的时候用到

** 密码学中的椭圆曲线
椭圆曲线是连续的, 不好用于加密解密, 考虑把椭圆曲线定义到有限域 F_{p} 上 (专业术语叫仿射变换):

y^{2} \equiv x^{3} + a * x + b (mod p), 其中 p 为素数, a, b 为非负整数 (TODO: 待考证), x \in F_{p}, y \in F_{p}

注: ECC 上的点, 我们只实现了加法, 只是一个群 (阿贝尔群); 但是它又分为 x 和 y 坐标, 均为 F_{p} 域内的点, 所以人们通常也会称为有限域内的点

** 常用 ECC
+ (比特币) p = 2^{256} - 2^{32} - 2^{9} - 2^{8} - 2^{7} - 2^{6} - 2^{4} - 1, a = 0, b = 7
+ p = 23, a = 1, b = 1
+ p = 11, a = 1, b = 6

注: 一种简单的构造方法, 可以先确定 a 和 一个点 P(x, y), 通过方程求出 b, p 的话可以任意选择 (但不应过小, 域太小没实际意义)

** 为什么 ECC 的零元是无穷远点
通常 ECC 的 b 的取值不为零, 所以代码实现时, 可以用 P(0, 0) 来代替无穷远点

因为 b \ne 0, 所以 P(0, 0) 不在椭圆曲线上, 可以借来使用

猜测: 可能是满足条件的零元不存在, 所以就造了一个出来, 赋予它特殊的计算规则, 反正它不在有限域上, 那就说它在无穷远点吧?

** ECC 的负元
观察椭圆曲线等式, 易知若 P(x, y) 是有限域上满足等式的点, 那么 P(x, -y) 也满足等式, 可以作为负元 (但需要一些调整)

因为 P(x, -y) 不在有限域上, 就像在 F_{5} 域内我们不能说 3 的负元是 -3, 而应该是 5 + (-3) = 2

同理, 根据二项式展开的性质, 知 P(x, p - y) 也满足等式, 且在有限域内, 作为负元再合适不过

*** 注1: 根据负元的定义 P(x, y) + P(x, p - y) = 0 (零元, 即无穷远点) 这一点在定义加法的时候要特别注意

*** 注2: 对于同一个 x = x1, 有限域内最多有两个点, 证明如下:
若对于 x = x1 有以下等式成立:
#+begin_src
+ y1^{2} \equiv x1^{3} + a * x1 + b (mod p)
+ y2^{2} \equiv x1^{3} + a * x1 + b (mod p)
#+end_src
由 mod p 的性质知: (y1 - y2) * (y1 + y2) \equiv 0 (mod p), 这里的加减法是域内的加减法, 且 p 为素数, 所以最多有两个点 P(x1, y1), P(x1, p - y1)

其中单个点的情况是 y1 = 0, 这时它的负元就是它自己, x 满足 x^{3} + a * x + b \equiv 0 (mod p)

** ECC 的加法
1. 规则一: 若 P2 为 P1 的负元, 规定 P1 + P2 = 0
2. 规则二 (为什么这样定义, 详见下一节的封闭性证明):
#+begin_src python
  if (x1, y1) != (x1, y2):
      k = (y2 - y1) / (x2 - x1)
  else:
      k = (3 * x1 ** 2 + a) / (2 * y1)
  x3 = k ** 2 - x1 - x2
  y3 = k * (x1 - x3) - y1
#+end_src

+ 注1: 很多资料都是把 k 写成 \lambda 的, 其实就是计算斜率
+ 注2: P1 != P2 时, 还是有可能 x2 = x1 的, 根据上一节的注2, 这时应用规则一
+ 注3: P1 = P2 时, 如果有 y1 = 0, 那么计算 k 时分母为零, 但这是不可能的, y1 = 0, 根据上一节的注2, 此时 P1 的负元就是它自己, 这时应用规则一
+ 注4: 上述规则二, 是为了同时能表示实数域上和有限域上才写成那样的; 实际在有限域上的除法就是用的 F_{p} 的除法, 最后也需要模 p (至于为什么可以这么做, 可能是仿射变换的性质吧)

** 加法的封闭性证明
很多资料多会讲, 椭圆曲线加法, 就是椭圆曲线上两点 (可相同) 确定的直线 (相同点时为切线) 与椭圆曲线的交点, 然后关于 x 轴翻转, 但没给出更进一步的解释

以下采用启发式证明的方式, 也就是我一步步发现的过程
*** 计算 y 坐标
我最先发现的是: y3 的计算可以看成 -(k * (x3 - x1) + y1), 这放在实数域上, 这就是根据斜率求 y 坐标, 然后再关于 x 轴翻转

*** 再看 k 的定义
+ P1 != P2 时就是斜率的计算公式
+ P1 = P2 时, 等式两边对 x 求导得 2 * y * f'(x) = 3 * x^{2} + a, 即 k = f'(x) = (3 * x^{2} + a) / (2 * y)

*** 再来计算 x 坐标
不妨令 z = y^{2},

那么椭圆曲线其实就是 xoz 坐标系上的三次曲线: z = x^{3} + a * x + b,

同样地, 那条直线在 xoz 坐标系上的方程是 z = (k * (x - x1) + x1)^{2},

两者相交就是 (k * (x - x1) + x1)^{2} = x^{3} + a * x + b, (式1)

是关于 x 的三次方程, 最多有三个解, 正好是我们知道的 x1, x2, x3, 可表示成 (x - x1) * (x - x2) * (x - x3) = 0 (式2)

然后比较两者关于 x 的二次项系数, 得出 -(x1 + x2 + x3) = -k^{2}

至此, 我们得到了之前的计算公式 x3 = k^{2} - x1 - x2,

就是说之前定义的加法其实就是求两点确定的直线与椭圆曲线的交点, 然后关于 x 轴翻转

对于任意两点, 相加有以下三种情况:
1. P1 = -P2, 结果是 0, 封闭
2. P1, P2 有一个为零元时, 根据零元的定义, 封闭
3. 其他情况, k 的计算都是有意义的 (除数不为 0), 结果存在并在椭圆曲线上, 封闭
综上所述, 我们证明了加法的封闭性

** 加法的交换律, 结合律
对于负元, 零元的情况, 显然满足交换律和结合律

一般情况, 交换律可根据定义直接得出

结合律看似容易, 其实需要非常复杂的计算 (带入之前的公式, 我是算不过来) 或者一些几何学的知识, 有兴趣可以研究研究: https://www.zhihu.com/question/296821640

** 椭圆曲线加密 (类比之前讲过的 ElGamal)
1. 生成私钥 k
2. 根据 G = (xg, yg), (椭圆曲线上约定点), 计算公钥 P = k * G = (xp, yp)
3. 加密: 发送消息 M 时, 随机临时私钥 r, 发送 C1 = r * G, C2 = r * P + M
4. 解密: k * C1 - C2 = k * r * G - r * k * G + M = M

** (ECDSA) (椭圆曲线数字签名算法)
类似 ElGamal, 设原私钥 k, 原公钥 P(xp, yp) = k * G,
NOTE: n 称为 G 的阶, 满足 n * G = O, 其中 O 为单位元, 例 E_{23}(1, 1) 上 (3, 10) 的阶为 28
1. 随机生成新私钥 r, R(xr, yr) = r * G (新公钥) 使得 xr != 0 (mod n)
2. s = r^{-1} * (hash(m) + xr * k), 满足 s != 0 (mod n), (否则重新从头来过)

验证: hash(m) * s^{-1} * G + xr * s^{-1} * P 就是 R(xr, yr)

用相同的 r 是不安全的, 详见:
https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm


网上有另一种方法, 看起来更简单
1. 同上
2. s = r - hash(m) * k (mod p)

验证: s * G + hash(m) * P 就是 R (判断只用 x 坐标)
因为 s * G = r * G - hash(m) * k * G = R - hash(m) * P

TODO: 我无法推导两者的等价关系, 也无法指出后一种是否存在不妥

*** 注意
+ 第一种方法要求 n 是素数, 所以 (23, 1, 1) 的例子并不合适, 并且其中的 r^{-1}, s^{-1} 都是 (mod n) 的逆元
+ 第二种方法没有这种要求

有限域上的椭圆曲线图, 对称轴并不是 x 轴, 而是 p / 2 (y = 0 时, 理论上不是对称的)

https://blog.csdn.net/zhuiyunzhugang/article/details/107589223
#+BEGIN_SRC rust
let ec = ECC::new(23, 1, 1);
assert_eq!(Point::new(4, 0), ec.mul_k_p_logn(14, &Point::new(3, 10)));
#+END_SRC

* RSA
+ 任取两个大素数 p, q
+ 计算 n = p * q (公钥1), \phi(n) = (p - 1) * (q - 1)
+ 任选大整数 e (公钥2), 满足 gcd(e, \phi(n)) = 1,
+ 确定密钥 d: 满足 d * e \equiv 1 (mod \phi(n))
+ 加密: 消息 M, 发送 C = M^{e} (mod n)
+ 解密: M = C^{d} (mod n) (证明略)

证明: M^{e * d} = M^{k * \phi(n) + 1}, 若 M 与 n 互素, 由欧拉定理即可得结论, 不互素情况详见: https://zhuanlan.zhihu.com/p/48994878

+ 注1: 确定密钥过程, 类似求逆元, 但因为 \phi(n) 不是素数, 所以可能不存在, 可以用扩展欧几里得算法求解
+ 注2: 安全依据: 大整数因式分解难题
