#+AUTHOR: wfj
#+EMAIL: wufangjie1223@126.com
#+OPTIONS: ^:{} \n:t email:t
#+HTML_HEAD_EXTRA: <style type="text/css"> body {padding-left: 26%; background: #e3edcd;} #table-of-contents {position: fixed; width: 25%; height: 100%; top: 0; left: 0; overflow-y: scroll; resize: horizontal;} i {color: #666666;} pre, pre.src:before {color: #ffffff; background: #131926;} </style>
#+HTML_HEAD_EXTRA: <script type="text/javascript"> function adjust_html(){document.getElementsByTagName("body")[0].style.cssText="padding-left: "+(parseInt(document.getElementById("table-of-contents").style.width)+5)+"px; background: #e3edcd;"}; window.onload=function(){document.getElementById("table-of-contents").addEventListener("mouseup",adjust_html,true)}</script>

* 密码学基础
** [定义] 什么是域 F(ield) ?
满足以下八条:
1. 对于加法和乘法运算封闭 (即域内任意两个元素相加或相乘仍在域内)
2. 加法和乘法均满足结合律
3. 加法和乘法均满足交换律
4. 满足分配律
5. 存在零元 0, 使得任意 a + 0 = a
6. 存在幺元 1, 使得任意 a * 1 = a
7. 存在加法逆元 (本文简称负元)
8. 非零元存在乘法逆元 (本文简称逆元)

** [数学描述]
1. \forall a, b \in F, a + b \in F, a * b \in F
2. \forall a, b, c \in F, (a + b) + c = a + (b + c), (a * b) * c = a * (b * c)
3. \forall a, b \in F, a + b = b + a, a * b = b * a
4. \forall a, b, c \in F, a * (b + c) = a * b + a * c
5. \exists 0, s.t. \forall a \in F, a + 0 = a
6. \exists 1 \ne 0, s.t. \forall a \in F, a * 1 = a
7. \forall a, \exists -a \in F, s.t. a + (-a) = 0
8. \forall a \ne 0, \exists a^{-1} \in F, s.t. a * a^{-1} = 1

** [性质]
由以上的定义, 我们可以在域内:
+ 定义减法: 加上一个负元
+ 定义除法: 乘以一个逆元 (要求非零元)
+ 定义数乘: 连续相加
+ 定义乘方: 连续相乘
+ 等式两边同时进行四则运算

** 常见的域
+ 有理数域
+ 实数域
+ 整数模 p, 记为 F_{p} (若无特殊说明, 本文的 p 均表素数)

注: 整数不是域, 因为除法不封闭

** [证明] 整数模 p 是一个域
+ 定义加法: 普通加法然后模 p
+ 定义乘法: 普通乘法然后模 p

显然满足定义的 1~6 条, 易知第 7 条也满足, 证明第 8 条如下:

对于域内的任意非零元 x, 分别乘以 0 到 p - 1, 然后模 p, 用反证法:

假设域内有两个不同的数 a, b, 使得 x * a \equiv x * b (mod p),

那么就有 x * (a - b) \equiv 0 (mod p),

又因为 p 是素数, 因子只能是 1 和 p, x 在域内不能是 p, a - b 在域内也不能是 p,

矛盾, 所以有这 x * 0~p 的余数各不相同, 所以必存在逆元 x^{-1} 使得余数为 1

例: F_{5}: 1^{-1} = 1, 2^{-1} = 3, 3^{-1} = 2, 4^{-1} = 4

特别地, 根据定义 6, 1 的逆元始终是 1

** 辗转相除法 (也称为扩展欧几里得算法)
求逆元如果每次都需要乘 1~p-1 遍历的话, 那么 p 很大的时候就相当低效了

求两个整数的最大公约数, 通过同余, 可以得到一种快速计算方法: 辗转相除法

非零元 a 和 p 互素, 所以最大公约数为 1, 也就是可以通过辗转相除最终得到 1, 这个 1 就是我们求逆元时想得到的 1,

因此, 我们可以反推辗转相除法的过程, 最终的余数 1 可以用 a 和 p 线性表出, a 前的系数就是我们要找的逆元

注: 确切地说, 这个系数可以是任意整数 (不一定在 F_{p} 内), 但能通过模 p, 转到 F_{p} 内, 且不会改变同余关系;

另一种做法是上述的计算都用 F_{p} 内定义的计算来进行, 由封闭性可得系数也在 F_{p} 内

*** 最大公约数
#+begin_src python
  def gcd(a, b): # a >= 0, b >= 0
      def _gcd(a, b):
	  return a if b == 0 else _gcd(b, a % b)
      return _gcd(a, b) if a > b else _gcd(b, a)
#+end_src

*** 求逆元
尾递归版本, 注: 本实现返回的数可能不在域内 (负数), 需要再 mod p
#+begin_src python
  def inv(a, b): # a >= 0, b >= 0
    def gcd(a, b, k1, k2):
        if b == 1:
            return k2
        k = a // b
        return gcd(b, a - k * b, k2, k1 - k * k2)
    return gcd(a, b, 0, 1) if a > b else gcd(b, a, 0, 1)
#+end_src

*** 实现原理
其实很朴素, 辗转相除有以下等式:
#+begin_src
+ a = k1 * p + p2                  (1)
+ p = k2 * p2 + p3                 (2)
+ ...
+ pn_2 = kn_1 * pn_1 + pn          (n-1)
+ pn_1 = kn * pn + 1               (n)
#+end_src

分析如下:
+ 由式 (1), 我们可以看出: 最终的展开式, 如果有一个 p2 那么就有一个 a, 而有多少个 p 对 a 无影响
+ 现假设有一个函数 f, 能够求出上述的对应关系, 那么我们就有 f(2) = 1, f(1) = 0 (即起始条件)
+ 由式 (n-1), 我们可以得出: f(n) = f(n - 2) - kn_1 * f(n - 1) 的递推关系
+ 由式 (n), 我们可以得出结束条件

** 群和环
+ 群: 集合 + 加法 (只实现了加法的 "域", 称为阿贝尔群, 条件再放宽一点还有其他各种群, 略)
+ 环: 集合 + 加法 + 乘法 (这个乘法的要求没域那么高, 比如整数环)

** [作用] 为什么是密码学的基础
F_{p} 上的四则运算会在密码学频繁用到, 我们知道了 F_{p} 是一个域, 那么我们就可以放心地做各种复杂的运算了

* ECC
** 参考资料
https://zhuanlan.zhihu.com/p/42629724

这篇文章, 背景介绍可以看看, 举的几个例子也很不错

例2 和例3 都手动算一算, 判断结果是否在 E_{23}(1, 1) 上

类比上面的 F_{p}, ECC 只实现了加法, 只是一个群

** ECC 的一般形式
E_{p}(a, b): y^{2} \equiv x^{3} + a * x + b (mod p)

a, b 为指定常数, 比特币用的是: a = 0, b = 7

** ECC 的零元是无穷远点
通常 ECC 的 b 的取值不为零, 所以代码实现时, 可以用 P(0, 0) 来代替无穷远点

因为 b \ne 0, 所以 P(0, 0) 不在椭圆曲线上, 可以借来使用

** ECC 的负元
观察 ECC 的一般形式, 易知 P(x, y) 若在椭圆曲线上, 那么 P(x, -y) 也满足同余也在椭圆曲线上, 那不妨定义为负元

*** 注1: 根据负元的定义 P(x, y) + P(x, -y) = 0 (即无穷远点) 这一点在定义加法的时候要特别注意

*** 注2: 对于同一个 x = x1, ECC 上最多只有两个点, 证明如下:
若对于 x = x1 有以下等式成立:
#+begin_src
+ y1^{2} \equiv x1^{3} + a * x1 + b (mod p)
+ y2^{2} \equiv x1^{3} + a * x1 + b (mod p)
#+end_src
由 mod p 的性质知: (y1 - y2) * (y1 + y2) \equiv 0 (mod p), 所以最多有两个点 P(x1, y1), P(x1, -y1)

** ECC 的加法和数乘
P1(x1, y1) + P(x2, y2)

计算 \lambda, 当 P1 != P2 时取 \lambda = (y2 - y1) / (x2 - x1) (几何上看这是个斜率, 代数上看要有意义得满足 x2 \ne x1)

当 P1 == P2 时, 取 \lambda = (3 * x2 + a) / (2 * y1) (这个有点像 ECC 一般形式, 两边求导)

TODO: 上述做法的原理还需要进一步研究

定义 P3(\lambda^{2} - x1 - x2, \lambda(x1 - x3) - y1) 为加法的结果

注意: P1 != P2 时, 有可能 x2 == x1 的, 这时是负元相加

# 加法只有 P1 != P2 时才能进行
# P3(x3, y3) = P1(x1, y1) + P2(x2, y2)
# (if P1 != P2) \lambda = \frac{y2 - y1}{x2 - x1} # 斜率?
# (else) \lambda = \frac{3 * x2 + a}{2y1}         # 分子函数求导?

*** 减法
减 P(x, y) 等于加上 P(x, -y)

推导 (先验: P3 != P1, 只有无穷远点是零元):
P3(x3, y3) + P4(x1, -y1), \lambda2 = \frac{y3 + y1}{x3 - x1} = -\lambda (根据上面的 y3 = 式), x5 = \lambda2^{2} - x1 - x3 = x2 (根据上面 x3 = 式), y5 = \lambda2 * (x1 - x5) - (-y1) = -\lambda * (x1 - x2) + y1 = (y2 - y1) + y1 = y2
也就是说 P3(x3, y3) + P4(x1, -y1) = P2(x2, y2), 证毕

** 加密 (ElGamal)
*** 一般形式
有 y \equiv g^{x} (mod p), 其中 (y, g, p) 为公钥, x 为密钥
对于要发送的消息 M (其二进制表示就是整数), 随机生成一个零时私钥 k, 我们可以通过发送 C1 = g^{k} 和 C2 = y^{k} * M, 那么拥有私钥的一方就可以通过 C2 / (C1^{x}) = y^{k} * M / g^{k*x} = M 来解密

*** 椭圆曲线 (类比一般形式)
私钥 k, 公钥 G = (xg, yg), P = k * G = (xp, yp)
消息 M, 随机私钥 r, 发送 C1 = r * G, C2 = r * P + M,
那么 k * C1 - C2 = k * r * G - r * k * G + M = M

** 数字签名 (ECDSA) (椭圆曲线数字签名算法)
类似 ElGamal, 设原私钥 k, 原公钥 P(xp, yp) = k * G,
NOTE: n 称为 G 的阶, 满足 n * G = O, 其中 O 为单位元, 例 E_{23}(1, 1) 上 (3, 10) 的阶为 28
1. 随机生成新私钥 r, R(xr, yr) = r * G (新公钥) 使得 xr != 0 (mod n)
2. s = r^{-1} * (hash(m) + xr * k), 满足 s != 0 (mod n), (否则重新从头来过)

验证: hash(m) * s^{-1} * G + xr * s^{-1} * P 就是 R(xr, yr)

用相同的 r 是不安全的, 详见:
https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm


网上有另一种方法, 看起来更简单
1. 同上
2. s = r - hash(m) * k (mod p)

验证: s * G + hash(m) * P 就是 R (判断只用 x 坐标)
因为 s * G = r * G - hash(m) * k * G = R - hash(m) * P

TODO: 我无法推导两者的等价关系, 也无法指出后一种是否存在不妥

** 注意
+ 第一种方法要求 n 是素数, 所以 (23, 1, 1) 的例子并不合适, 并且其中的 r^{-1}, s^{-1} 都是 (mod n) 的逆元
+ 第二种方法没有这种要求

有限域上的椭圆曲线图, 对称轴并不是 x 轴, 而是 p / 2 (y = 0 时, 理论上不是对称的)

https://blog.csdn.net/zhuiyunzhugang/article/details/107589223
#+BEGIN_SRC rust
let ec = ECC::new(23, 1, 1);
assert_eq!(Point::new(4, 0), ec.mul_k_p_logn(14, &Point::new(3, 10)));
#+END_SRC

* RSA
任取两个大素数 p, q
n = p * q (公钥1)
\phi(n) = (p - 1) * (q - 1) # 欧拉
任选大整数 e (公钥2), 满足 gcd(e, \phi(n)) = 1,

任选密钥 d, 满足 d * e \equiv 1 (mod \phi(n)) (即求逆元)
将消息 m 加密 c = m^{e} (mod n)
解密: m = c^{d} (mod n) (证明略)

欧拉定理: 正整数 n 和 a 互素, 那么 a^{\phi(n)} \equiv 1 (mod n)
\phi(n) 称为欧拉函数, 是小于 n 的正整数中和 n 互素的个数
标准因式分解 n = p1^{x1}*...*pn^{xn}
\phi(n) = n * (1 - 1/x1)*...*(1 - 1/xn)
